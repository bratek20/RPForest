% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia sie przede wszystkim jezyk i rodzaj (lic/inz/mgr) pracy, oraz czy na
% drugiej stronie pracy ma byc skladany wzor oswiadczenia o autorskim wykonaniu.
\documentclass[inz,longabstract]{iithesis}

\usepackage[utf8]{inputenc}

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak.
\polishtitle    {Realistyczny rendering krajobrazów leśnych\fmlinebreak generowanych proceduralnie}
\englishtitle   {Realistic rendering of procedural generated forest landscapes}
\polishabstract {Strzeszczenie po polsku\ldots}
\englishabstract{English abstract\ldots}
% w pracach wielu autorow nazwiska mozna oddzielic poleceniem \and
\author         {Bartosz Rudzki}
% w przypadku kilku promotorow, lub koniecznosci podania ich afiliacji, linie
% w ponizszym poleceniu mozna zlamac poleceniem \fmlinebreak
\advisor        {dr Andrzej Łukaszewski}
%\date          {}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
\transcriptnum {291481}                     % Numer indeksu
\advisorgen    {dr Andrzeja Łukaszewskiego} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
%
%\usepackage{graphicx,listings,amsmath,amssymb,amsthm,amsfonts,tikz}
\usepackage{graphicx, amsmath, gensymb, float, textcomp}
%
%%%%% WŁASNE DEFINICJE I POLECENIA
\graphicspath{{./pictures/}}
%\theoremstyle{definition} \newtheorem{definition}{Definition}[chapter]
%\theoremstyle{remark} \newtheorem{remark}[definition]{Observation}
%\theoremstyle{plain} \newtheorem{theorem}[definition]{Theorem}
%\theoremstyle{plain} \newtheorem{lemma}[definition]{Lemma}
%\renewcommand \qedsymbol {\ensuremath{\square}}
% ...
%%%%%

\begin{document}

%%%%% POCZĄTEK ZASADNICZEGO TEKSTU PRACY
\chapter{Wprowadzenie}
    Pracy skupia się na zbadaniu i zastosowaniu dwóch pojęć z dziedziny grafiki komputerowej: realistyczny rendering i generowanie proceduralne. 
    
    Pierwsze zagadnienie dotyczy przedstawienia wcześniej przygotowanego modelu w sposób zrozumiały dla człowieka. Modelem może być plik opisujący kształt dzbanka. Przykładowa reprezentacja to zbiór trójkątów rozmieszczonych w przestrzeni z uwzględnieniem dodatkowych informacji takich np. kolor. Rendering takiego modelu polegałby na zamianie wszystkich tych danych na obraz, który mógłby być pokazany człowiekowi. O realistycznym renderingu możemy mówić wtedy, kiedy stworzony przez nas obraz przypomina prawdziwy dzbanek, który chcieliśmy zamodelować. 
    
    Generowanie proceduralne skupia się na tworzeniu modeli przy pomocy algorytmów. Człowiek może wpływać na finalny produkt przy pomocy zmiany parametrów jednak nie uczestniczy w samym procesie tworzenia. Jest to bardzo wydajna metoda pozwalająca na tworzenie nieskończenie wielu różnych modeli o zadanych właściwościach jak np. rośliny.
    
    Celem programu napisanego w ramach tej pracy jest generowanie prostego krajobrazu leśnego, a następnie względnie realistyczny rendering stworzonego środowiska. Sam program jest wysoce sparametryzowany, dzięki czemu użytkownik może realnie wpływać na finalny rezultat.
    
\chapter{Zastosowane rozwiązania}
    W tym rozdziale przedstawię najważniejsze rozwiązania, które zastosowałem w swoim programie. Postaram przybliżyć się najważniejsze zagadnienia głownie po to, aby potencjalny użytkownik programu świadomie mógł wpływać na jego działanie. 
    
    \section{Generowanie proceduralne}
        \subsection{Rośliny}
            Kształt roślin posiada wiele regularności. Dzięki temu można opisać je przy pomocy tak zwanych L-systemów. Jest to sposób reprezentacji modelu pod postacią zestawu reguł tworzących gramatykę. Zaczynając od jednego symbolu jesteśmy wstanie wygenerować zbiór symboli --- słowo. Osiągamy to poprzez zdefiniowanie dodatniej liczby różnych produkcji. Są to reguły zamieniania wybranego symbolu na słowo. Przykładowy L-System może wyglądać następująco:
            \begin{align*}
                axiom &: \alpha \\
                prod1 &: \alpha \rightarrow \alpha\beta\alpha \\
                prod2 &: \beta \rightarrow \beta\beta
            \end{align*}
            Produkcje aplikowane są jednocześnie w obrębie jednej iteracji. Podając liczbę iteracji możemy generować coraz dłuższe ciągi. Dla N = 1 otrzymujemy $\alpha\beta\alpha$, a dla N = 2 mamy $\alpha\beta\alpha\beta\beta\alpha\beta\alpha$.
            
            Finalnym produktem L-systemu jest słowo, które możemy potraktować jako polecenia dla rysującego żółwia. Żółw czytając słowo od lewej do prawej będzie interpretować każdy symbol jako komendę. Przykłady poleceń to: idź prosto rysując linię albo skręć w lewo o wcześniej ustalony kąt. W przypadku gdy żółw nie zna symbolu nie robi nic i czyta dalej. Rysunek \ref{fig:turtleExample} przedstawia przykładową interpretację słowa $\alpha\beta\alpha\beta\beta\alpha\beta\alpha$ gdzie $\alpha$ to idź naprzód, a $\beta$ skręć w lewo o 30\degree.
            \begin{figure}[H]
                \includegraphics[width=\linewidth]{turtleExample.png}
                \caption{Interpretacja dla słowa $\alpha\beta\alpha\beta\beta\alpha\beta\alpha$, gdzie $\alpha$ to idź naprzód, a $\beta$ skręć w lewo o 30\degree.}
                \label{fig:turtleExample}
            \end{figure}
            
            Aby żółw był wstanie rysować rośliny potrzebujemy symbol pozwalający się rozgałęziać. Można osiągnąć to poprzez dodanie stosu pamiętającego aktualny stan żółwia oraz symbole na nim operujące:
            \begin{description}\itemsep=5ex
                \item[{[}] - odłóż aktualny stan na stos
                \item[{]}] - ściągnij i zaaplikuj stan z góry stosu 
            \end{description}
            Stanem żółwia jest wszystko co zmienia się przy pomocy symboli np. pozycja, orientacja lub długość rysowanej linii. Rysunek \ref{fig:lsystemPlants} pokazuje przykładowe L-systemy z książki \textit{The Algorithmic Beauty of Plants}\cite{plants}, które używają symboli tworzących rozgałęzienia. 
            \begin{figure}[H]
                \includegraphics[width=\linewidth]{lsystemPlants.png}
                \caption{Przykład użycia symboli operujących na stosie\cite{plants}} 
                \label{fig:lsystemPlants}
            \end{figure}
            
            Wspomniana wcześniej książka Prusinkiewicza i Lindenmayer'a\cite{plants} dokładnie opisuje L-systemy jako zagadnienie naukowe oraz podaje wiele przykładów produkcji tworzących realistycznie wyglądające rośliny. Część z nich wymaga bardziej zaawansowanych technik produkcji symbolów np. L-systemy parametryczne. Do tej pory zakładaliśmy, że wszystkie parametry (np. kąt skrętu, długość kroku) były ustalone na początku i nie zmieniały się. Parametryzując symbole i produkcje możemy wpływać lepiej na finalny kształt. Ma to zastosowanie między innymi w generowaniu drzew. Rysunek \ref{fig:hondaTrees} przedstawia produkcje drzew wymyślonych przez Hondę\cite{honda}, a pokazanych u Prusinkiewicza\cite{plants}.
            \begin{figure}[H]
                \includegraphics[width=\linewidth]{hondaTrees.png}
                \caption{L-system parametryczny generujący drzewa \cite{plants}\cite{honda}} 
                \label{fig:hondaTrees}
            \end{figure}
            
            L-systemy mogę również generować wielokąty. Jest to szczególnie przydatne w tworzeniu liści. Rysunek \ref{fig:lsystemLeafs} prezentuje kilka rodzajów liści wygenerowanych z jednego L-systemu. Możliwe jest to dzięki wprowadzeniu nowych symboli:
            \begin{description}
                \item[\texttt{\{}] - zacznij tworzyć nowy wielokąt 
                \item[.] - zapisz aktualną pozycję jako wierzchołek
                \item[\texttt{\}}] - zakończ aktualny wielokąt
            \end{description}
            \begin{figure}[H]
                \includegraphics[width=\linewidth]{lsystemLeafs.png}
                \caption{L-system parametryczny generujący liście \cite{plants}} 
                \label{fig:lsystemLeafs}
            \end{figure}
            
            Wcześniej opisane zastosowania L-systemów pokazują dlaczego jest to idealny kandydat do tworzenia realistycznych modeli roślin. Różnorodność definiowanych kształtów, rozbudowywanie funkcjonalności poprzez dodawanie nowych symboli oraz łatwe parametryzowanie to jedne z wielu zalet tej techniki. Wszystko to sprawia, że L-systemy są często wykorzystywane w wielu różnych projektach - również w tym. 
            
        \subsection{Teren}
            Problem generowania terenu można sprowadzić do problemu generowania mapy wysokości. Jest to macierz wypełniona liczbami reprezentującymi wysokość wybranych punktów. Owe punkty pomiaru rozłożone są równomiernie na osi X i Z. Mając taką macierz w łatwy sposób jesteśmy wstanie wygenerować teren - tworzymy kwadraty dla każdej czwórki sąsiadujących punktów - patrz rysunek \ref{fig:heightmap}. 
            \begin{figure}[H]
                \includegraphics[width=\linewidth]{heightmap.png}
                \caption{Przykładowy teren wygenerowany przy użyciu mapy wysokości\cite{heightmap}} 
                \label{fig:heightmap}
            \end{figure}
            
            Istnieje wiele algorytmów generujących mapy wysokości. Mój wybór padł na tak zwany \textit{Diamond-square algorithm}. Dla ustalonego N generuje on mapę wysokości o rozmiarze $2^N$+1 x $2^N$+1. Na początku ustala się wartości w rogach macierzy. Następnie wykonuje się na przemiennie fazę diamond i square, aż do ustalenia wszystkich wysokości. 
            
            Faza diamond polega na wygenerowaniu wysokości w środku każdego kwadratu, który nie ma ustalonej tej wartości. Faza square robi to samo tylko, ze dla punktów tworzących kształt rombu. Rysunek \ref{fig:diamondSquare} obrazuje przebieg algorytmu. 
            \begin{figure}[H]
                \includegraphics[width=\linewidth]{diamondSquare.png}
                \caption{Przebieg algorytmu diamond-square dla N = 2.} 
                \label{fig:diamondSquare}
            \end{figure}
            
            Obliczanie nowej wartości w środku polega na wzięciu średniej z wysokości wierzchołków tworzących kształt (kwadrat, romb). Dodatkowo dodajemy do obliczanej wartości pewien czynnik losowy, z przedziału (-X, X) dla ustalonego X. Dla każdej kolejnej pary faz ów czynnik jest zmniejszany poprzez przemnożenie go przez pewne $R < 1$.
            
            \textit{Diamond-square algorithm} jest zarówno prosty jak i efektywny. Ustalając kilka parametrów jesteśmy wstanie tworzyć bardzo różnorodny teren. 
            
        \subsection{Tekstury}
            Mając wygenerowany model - kształt,  musimy nadać mu również kolor. Jednym z założeniem programu było w pełni proceduralne podejście. Dotyczy to również tekstur. Każda tekstura w programie opisywana jest przez materiał. Materiał oblicza kolor na podstawie funkcji \textit{calcDiffuse(pos3D) \textrightarrow color}, gdzie $pos3D$ to pozycja w świecie. W celu uproszczenia i ujednolicenia systemu zdecydowałem się zaimplementować jeden wzór, który został zastosowany do każdego materiału. Wygląda on następująco:
            \begin{gather*} \label{eqn:material}
                calcDiffuse(pos3D) = mix(color1, color2, factor) \\
                gdzie \\
                factor = clamp(noise(pos3D * posF) * valF, 0, 1)
            \end{gather*}
            

            Finalny kolor to mieszanka $color1$ i $color2$ w stosunku $1 - factor$ i $factor$. Sam $factor$ to odpowiednio obliczona wartość szumu Perlina. Dzięki $posF$ możemy skalować szum, a dzięki $valF$ możemy wymuszać faworyzowanie wartości bliższych 0 albo 1.
            
            Jedynym materiałem w programie odbiegającym od tej metody jest materiał terenu. Łączy on ze sobą dwa inne materiały - grunt i skały. Do pewnej ustalonej wysokości kolor obliczany jest tylko dla gruntu. Analogicznie powyżej pewnego poziomu stosuję tylko kolor skał. Po środku dochodzi do mieszania kolorów w stosunku zależnym od odległości do ustalonych granic:
            \begin{gather*}
            mix(calcRockColor(pos), calcGroundColor(pos), groundFactor) \\
            gdzie \\
            groundFactor = (groundEndY - posY) / (groundEndY - rockStartY) \\
            \end{gather*}
            
            Zaprezentowane rozwiązanie okazało się wystarczające, aby osiągnąć zadowalające rezultaty. Jest łatwe do implementacji, ujednolicone dla użytkownika oraz na tyle rozbudowane, aby wyrażać niebanalną kolorystkę.
            
        \subsection{Rozmieszczanie roślin}
            Po wygenerowaniu wystarczającej liczby modeli roślin trzeba je umieścić w świecie. Można to robić w mniej lub bardziej wyszukany sposób. W tym przypadku zdecydowałem się na jedno z najprostszych rozwiązań - losowe rozmieszczanie wewnątrz komórek kraty. Krata o wymiarach N x M posiada $N * M$ kwadratowych komórek o ustalonym rozmiarze. Wewnątrz takiej komórki z pewnym prawdopodobieństwem możemy umieścić losowy model. Pozycja modelu wewnątrz kraty również jest losowa i może zostać ograniczona przez parametr mówiący jak bardzo od środka może zostać wylosowana pozycja. Przykładowo dla wartości 0 obiekt zawsze będzie umieszczany w środku kraty, a dla 1 może pojawić się w całej kracie. 
            
        \subsection{Wybór miejsca renderingu}
            Aby teren wydawał się realistyczny musi zajmować dużą część świata. Dobrze byłoby wpływać na to czy chcemy renderować naszą scenę ze szczytu góry czy z terenu nizinnego. W jakim kierunku powinna być skierowana kamera oraz co ważniejsze uwzględniać ukształtowanie otaczającego ją terenu. W przypadku gdy kamera zostanie umieszczona przed górą chcielibyśmy, aby patrzyła do góry, a kiedy jest na szczycie w dół. 
            
            Odpowiednie umieszczenie możemy wybrać poprzez parametr sugerujący na jakiej wysokości chcemy się znajdować. Dobrze zdefiniować również minimalną odległość od krawędzi końca świata, aby uniknąć sytuacji patrzenia w pustą przestrzeń. Żeby uwzględnić ukształtowanie terenu przy kierunku patrzenia możemy dodać parametr mówiący jak daleko od nas znajduję się miejsce które nas interesuje. Następnie obliczamy wysokość tego miejsca i korygujemy nasz kierunek patrzenia względem otrzymanej wartości.
            
        \subsection{Ograniczenie liczby modeli}
            Przy generowaniu tak dużego świata musimy liczyć się z ograniczeniami sprzętowymi. Niezoptymalizowane modele otrzymywane z L-systemów mają nawet po kilkanaście tysięcy trójkątów! W takim przypadku dobrym sposobem tworzenia sceny jest umieszczenia wszystkich generowanych modeli względnie blisko kamery. Duże modele będą zasłaniać znaczną część pola widzenia ukrywając niewypełnioną przestrzeń. Rozwiązanie nie jest idealne ale ma szanse wygenerować scenę o zadowalającym rezultacie.
            
    \section{Realistyczny rendering}
        Do tej pory opisywałem techniki pozwalające generowanie różnych modeli składających się w jeden wielki świat. W tej sekcji skupię się jak uchwycić część tego co udało się stworzyć. Sam proces zwany renderingiem w tym przypadku przypominać będzie nic innego jak zrobienie zdjęcia. Wcześniej wspomniałem o koncepcie kamery, która znajduje się w świecie oraz jest zwrócona w określonym kierunku. To co należy zrobić teraz to uchwycić obraz z jej perspektywy. 
        
        \subsection{Path tracer}
            Głównym zadaniem path tracer'a jest obliczanie koloru docierającego do kamery z ustalonego kierunku. Kolor w tym przypadku to nic innego jak promień światła, który po wielu odbiciach dotarł do kamery. Postaramy odtworzyć się to zjawisko, z tym wyjątkiem, że promień zostanie wypuszczony od kamery i będzie podążać do światła. Cały proces jest wysoce losowy, jako że promień mógł dotrzeć do nas wieloma różnymi ścieżkami. W celu otrzymania jak najlepszych wyników w jednym kierunku będziemy puszczać wiele promieni, a na końcu je uśrednimy.
            
            Aby otrzymać realistyczny obraz path tracer przy obliczaniu koloru będzie korzystać z tak zwanego \textit{równania renderingu}. Samo równanie korzystając z zasady zachowania energii wylicza radiancję światła wychodzącą z ustalonego punktu na płaszczyźnie dla zadanego kierunku. W uproszczonej formie wygląda ono następująco:
            
            \begin{equation}
            L_o = L_e + \int_{\Omega} L_i*f_r*cos\theta*d\omega_i
            \end{equation}

            
        \subsection{Niebo}
            Path tracing często stosuje się dla zamkniętych scen z kilkoma źródłami światła. W przypadku rendorowania krajobrazów mamy do czynienia z czymś zupełnie innym. Mamy jedno źródło światła (słońce) oraz pół otwartą scenę z wielkim niebem pochłaniającym większość promieni. Fizycznie poprawny model nieba został opisany w pracy \textit{A Practical Analytic Model for Daylight}\cite{sky}, która powstała na Uniwersytecie w Utah. Opisuje on niebo w danym miejscu na ziemi o ustalonej porze. 
            
            Został również udostępniony gotowy kod implementujący zaprezentowane rozwiązanie. Dołączyłem go do swojego programu i korzystam z niego jak z zewnętrznej biblioteki nie wnikając w szczegóły implementacyjne. Niebo w moim programie to półsfera rozciągająca się nad całym wygenerowanym terenem. Implikuje to, że im większy jest teren, tym większe jest niebo.
        
        \subsection{Słońce}
            O ile model nieba z poprzedniej sekcji dobrze oddaje kolorystykę nieba to jest ona dosyć jednolita. Dodatkowo jako, że niebo otacza scenę praktycznie z każdej strony, to nie może być traktowane jako główne źródło światła. Żeby otrzymać ładne cienie obiektów dołożyłem dodatkowo własne słońce jako źródło światła o dużej mocy. Model nieba oblicza również pozycję słońca i korzystam z tego, aby odpowiednio umieścić moje. Umieszczam je na półsferze nieba stąd odległość słońca od ziemi jest zależna od wielkości terenu (patrz poprzednia sekcja).
            
\chapter{Poradnik użytkowania}
    Poprzedni rozdział opisywał rozwiązania, które zastosowałem w programie. Ten skupi się jak uruchomić program oraz na przedstawieniu w jaki sposób można wpływać na rendering i generowane elementy.
    
    \section{Uruchomienie programu}
        W celu kompilacji programu należy uruchomić skrypt \textit{build.sh} w głównym katalogu. Utworzy on folder \textit{build}, który posłuży jako miejsce dla plików programu \textit{cmake}. Dodatkowo w folderze bin powinien pojawić się plik binarny do uruchamiania programu - \textit{rpforest.exe}. Program posiada dwa opcjonalne argumenty wywołania. 
        
        Pierwszy to ścieżka do pliku konfiguracyjnego path tracingu. Kilka przykładowych plików znajduje się w folderze bin. Wszystkie mają rozszerzenie \textit{.rtc} i ich struktura zostanie opisana w kolejnej sekcji. W przypadku nie podania ścieżki zostanie załadowany plik \textit{default.rtc}.
        
        Drugi argument to ziarno losowości. W przypadku nie ustawienia żadnego, zostanie wybrane losowe - zależne od czasu. W logach programu można znaleźć ziarno dla danego uruchomienia. Możemy wybrać je podobnie jeśli chcemy wygenerować ten sam świat. 
        
    \section{Pliki konfiguracyjne}
        Każdy plik konfiguracyjny jest parsowany w ten sam sposób. Pojedynczy wpis składa się z nazwy parametru i argumentów zależnych od typu parametru. Kolejność nie ma znaczenia. Każdy parametr musi być zdefiniowany w osobnej linii. Część parametrów ma domyślne wartości. 
        
        Prawie wszystkie pliki znajdują się w folderze \textit{assets} lub jego podfolderach. Ich rozszerzenia mają znaczenie. Jeśli plik nie konfiguruje pojedynczej funkcjonalności (teren, niebo itd.), to można wyłączyć jego wczytywanie poprzez zmienienie rozszerzenia.
        
        Poniżej zostaną opisane parametry poszczególnych plików konfiguracyjnych. Przyjęta konwencja to:
        \begin{itemize}
            \item \textit{NazwaParametru : typ = wartość domyślna jeśli istnieje} - opis
        \end{itemize}
        
        \subsection{Ustawienia path tracingu}
        Jedyny plik konfiguracyjny, który nie jest wczytywany z folderu \textit{assets}. Opisuje ustawienia path tracingu. Jako, że użytkownik może mieć kilka różnych przydatnych ustawień (np. debug lub highQuality) to wczytywany on jest poprzez podanie ścieżki w argumencie wywołania programu. Kilka przykłądowych plików znajduje się w folderze \textit{bin} i mają rozszerzenie \textit{.rtc}.
        
        Można zdefiniować następujące parametry:
        \begin{itemize}
            \item \textit{PhotoName : string} - nazwa pliku do którego zostanie zapisany finalny render. Będzie on w formacie exr i umieszczony zostanie w folderze \textit{photos}.
            \item \textit{Resolution : vec2} - rozmiar renderowanej fotografii oraz wielkość okna debuggerskiego
            \item \textit{Samples : int = 1} - liczba promieni wystrzelona per jeden pixel
            \item \textit{MaxRayBounces : int = 5} - maksymalna dopuszczalna liczba odbić jednego promienia  
            \item \textit{DebugMode : bool = 0} - jeśli wartość jest ustawiona na 1 to program otworzy się w trybie debuggerskim
        \end{itemize}

        \subsection{Ustawienia kamery}
        Plik opisujący ustawienia kamery. Znajduje się pod ścieżką
        \textit{assets/configs/camera.conf}.
        
        Parametry:
        \begin{itemize}
            \item \textit{LookHeight : float = 1} - wysokość liczona od  powierzchni ziemi 
            \item \textit{LookDirection : vec3 = 0 0 1} - kierunek patrzenia 
            \item \textit{LookDistance : float = 2} - odległości od kamery względem której zostanie dostosowane pochylenie kamery (patrzenie pod góre/w dół)
            \item \textit{EdgeMinOffset : float = 10} - minimalna odległość od krawędzi świata  
            \item \textit{ExpectedPositionY : float = 0} - oczekiwana pozycja Y, na której powinna zostać umieszczona kamera. Dzięki temu można wymuszać np. robienie zdjęć ze szczytów gór. 
            \item \textit{DebugVelocity : float = 10} - szybkość poruszania się kamery w trybie debuggerskim
        \end{itemize}
        
        \subsection{Ustawienia nieba}
        Plik do konfiguracji nieba. Ścieżka: 
        \textit{assets/configs/sky.conf}. Większość parametrów służy do ustawień parametrów modelu nieba opracowanego w pracy z Uniwersytetu w Utah\cite{sky}.
        
        Parametry słońca:
        \begin{itemize}
            \item \textit{SunColor : vec3} - kolor słońca 
            \item \textit{SunPower : float} - moc słońca
        \end{itemize}
        
        Parametry modelu nieba:
        \begin{itemize}
            \item \textit{SkyLuminanceFactor : float} - mnożnik do zmniejszania jasności pochodzącej od nieba
            \item \textit{Latitude : float} - szerokość geograficzna
            \item \textit{Longitude : float} - długość geograficzna
            \item \textit{StandardMeridian : int} - numer strefy czasowej
            \item \textit{JulianDay : int} - dzień
            \item \textit{TimeOfDay : float} - czas
            \item \textit{Turbidity : float} - zagęszczenie mgły 
        \end{itemize}
        
        \subsection{Ustawienia terenu}
        Ścieżka do pliku: \textit{assets/configs/terrain.conf}. Ustawienia terenu wpływające na algorytm \textit{diamond-square} oraz teksturowanie:
        \textit{terrain.conf}
        \begin{itemize}
            \item \textit{N : int} - wpływa na liczbę elementów mapy wysokości. Finalny rozmiar to $2^N$+1 x $2^N$+1.
            \item \textit{Size : float} - wielkość generowane terenu 
            \item \textit{InitHeight : float} - wartość do wyliczania początkowych wartości na rogach mapy. Zostaną wylosowane z przedziału (-\textit{InitHeight}:\textit{InitHeight}).
            \item \textit{Spread : float} - początkowa rozpiętość losowej wysokości dodawanej do uśrednianych wartości
            \item \textit{SpreadReductionRate : float} - jak zmienia się rozpiętość wzgledem kolejnych iteracji algorytmu 
            \item \textit{RockStartY : float = 10} - od jakiej wysokości powinnien być aplikowany materiał skał
            \item \textit{GroundEndY : float = 20} - do jakiej wysokości powinien być aplikowany materiał gruntu
        \end{itemize}
        
        \subsection{Ustawienia Tekstur}
        Wszystkie pliki konfiguracyjne materiałów znajdują się w folderze \textit{assets/materials} i mają rozszerzenie \textit{.mat}. W plikach ustala się wartości parametrów ze wzoru \ref{eqn:material}. 
        \begin{itemize}
            \item \textit{Color1 : vec3} - pierwszy kolor do mieszania
            \item \textit{Color2 : vec3} - drugi kolor do mieszania
            \item \textit{NoisePositionFactor : float = 1} - czynnik zmieniający pozycję obliczania szumu 
            \item \textit{NoiseValueFactor : float = 1} - czynnik zmieniający wartość szumu
        \end{itemize}
        
        \subsection{Bazowe ustawienia generatorów}
        Program pozwala definiować własne L-systemy oraz udostępnia kilka predefiniowanych. Oba podejścia konfigurowane są przez odpowiednie pliki, które współdzielą część parametrów:
        
        \begin{itemize}
            \item \textit{N : int} - liczba iteracji aplikowania produkcji L-systemu 
            \item \textit{Height : float} - finalna wysokość wygenerowanego modelu
            \item \textit{ConeBasePoints : int = 3} - ile punktów w podstawie mają cylindry tworzące model
            \item \textit{Material : string} - nazwa materiału (Leaf, Bark, Plant)
            \item \textit{InitRadius : float} - początkowy promień cylindrów tworzących model
        \end{itemize}
        
        \subsection{Definiowanie własnych L-systemów}
        Wszystkie pliki definiujące własne L-systemy mają rozszerzenie \textit{.lsys}. Można umieścić je w jednym z trzech folderów: \textit{trees}, \textit{plants}, \textit{leafs}. Znajdują się one w folderze \textit{assets}. Umieszczenie wpływa na to jak program będzie traktować dany L-system.
        
        \begin{itemize}
            \item \textit{TurnAngle : float = 0} - kąt skrętu żółwia w lewo/prawo
            \item \textit{PitchAngle : float = 0} - kąt skrętu żółwia w dół/górę 
            \item \textit{RollAngle : float = 0} - kąt skrętu wokół własnej osi
            \item \textit{Axiom : char} - początkowy symbol
            \item \textit{Prod : char $>$ string } - pojedyncza definicja produkcji. Plik może zawierać kilka takich wpisów (każdy w osobnej linii) i wszystkie zostaną uwzględnione. Poprawny zapis to symbol, znak $>$ (dla lepszej czytelności) i produkowane słowo np. \textit{Prod A $>$ ABC}. 
        \end{itemize}
        
        \subsection{Ustawienia predefiniowanych L-systemów}
        W programie zostały zaimplementowane dwa L-systemy: jeden do generowania drzew, drugi do liści.
        
        Pliki konfiguracyjne do do generowania drzew mają rozszerzenie \textit{.honda} i znajdują się w folderze \textit{assets/trees}. Opisują one wartość L-systemu wymyślonego przez Hondę\cite{honda} i zaprezentowanego przez Prusinkiewicza\cite{plants} - patrz Rysunek \ref{fig:hondaTrees}.
        
        Parametry z rysunku z dokładnością do wielkości liter:
        \begin{itemize}
            \item \textit{R1 : float} - współczynnik zmniejszania długości pnia
            \item \textit{R2 : float} - współczynnik zmniejszania długości gałęzi
            \item \textit{A0 : float} - kąt pod którym rosną gałęzie
            \item \textit{A2 : float} - kąt pod którym wyrastają pomniejsze gałęzie
            \item \textit{D : float} - kąt o ile rotuje wokół własnej osi żółw po stworzeniu gałęzi
            \item \textit{Wr : float} - współczynnik zmniejszania promienia pnia i gałęzi
        \end{itemize}    
        
        \textit{.family}
        \begin{itemize}
            \item \textit{Delta : float} -
            \item \textit{LA : float} -
            \item \textit{RA : float} -
            \item \textit{LB : float} -
            \item \textit{RB : float} -
            \item \textit{PD : float} -
        \end{itemize}    
        
        \subsection{Ustawienia rozmieszczania roślin}
        \textit{.spawner}
        \begin{itemize}
            \item \textit{CameraOffset : vec2} -
            \item \textit{XGridN : int = 1} -
            \item \textit{ZGridN : int = 1} -
            \item \textit{CellSize : float = 0} -
            \item \textit{GeneratorType : string} -
            \item \textit{SpawnProbability : float = 1} -
            \item \textit{RandomPositionPercentage : float = 0.5} -
            \item \textit{MinElementScale : float = 0.5} -
            \item \textit{MaxElementScale : float = 2} -
        \end{itemize}
        
    \section{Tryb debuggerski}
        
\chapter{Szczegóły programistyczne}

\chapter{Przykłady użycia}

%%%%% BIBLIOGRAFIA

\bibliographystyle{unsrt}
\bibliography{bibliography}

%\begin{thebibliography}{1}
%\bibitem{example} \ldots
%\end{thebibliography}

\end{document}
